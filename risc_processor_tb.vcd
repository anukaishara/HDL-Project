$date
	Mon Jun 30 09:24:05 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_risc_processor $end
$var wire 8 ! alu_result [7:0] $end
$var wire 16 " instruction [15:0] $end
$var wire 1 # mem_write $end
$var wire 3 $ opcode [2:0] $end
$var wire 8 % pc_current [7:0] $end
$var wire 1 & pc_src $end
$var wire 8 ' read_data2 [7:0] $end
$var wire 8 ( regs_0 [7:0] $end
$var wire 8 ) regs_1 [7:0] $end
$var wire 8 * regs_2 [7:0] $end
$var wire 8 + regs_3 [7:0] $end
$var wire 8 , data_out [7:0] $end
$var reg 1 - clk $end
$var reg 8 . external_data_in [7:0] $end
$var reg 1 / reset $end
$scope module uut $end
$var wire 1 - clk $end
$var wire 8 0 external_data_in [7:0] $end
$var wire 1 / reset $end
$var wire 8 1 write_data_reg [7:0] $end
$var wire 2 2 rs2 [1:0] $end
$var wire 2 3 rs1 [1:0] $end
$var wire 1 4 reg_write $end
$var wire 8 5 read_data2 [7:0] $end
$var wire 8 6 read_data1 [7:0] $end
$var wire 2 7 rd [1:0] $end
$var wire 1 8 pc_src $end
$var wire 8 9 pc_plus1 [7:0] $end
$var wire 8 : pc_next [7:0] $end
$var wire 8 ; pc_current [7:0] $end
$var wire 3 < opcode [2:0] $end
$var wire 1 = mem_write $end
$var wire 1 > mem_to_reg $end
$var wire 8 ? mem_read_data [7:0] $end
$var wire 1 @ mem_read $end
$var wire 16 A instruction [15:0] $end
$var wire 8 B immediate [7:0] $end
$var wire 8 C data_out [7:0] $end
$var wire 1 D alu_src $end
$var wire 8 E alu_result [7:0] $end
$var wire 2 F alu_op [1:0] $end
$var wire 8 G alu_b [7:0] $end
$scope module alu_inst $end
$var wire 8 H b [7:0] $end
$var wire 2 I op [1:0] $end
$var wire 8 J a [7:0] $end
$var reg 8 K result [7:0] $end
$upscope $end
$scope module ctrl $end
$var wire 3 L opcode [2:0] $end
$var reg 2 M alu_op [1:0] $end
$var reg 1 D alu_src $end
$var reg 1 @ mem_read $end
$var reg 1 > mem_to_reg $end
$var reg 1 = mem_write $end
$var reg 1 8 pc_src $end
$var reg 1 4 reg_write $end
$upscope $end
$scope module dmem $end
$var wire 8 N address [7:0] $end
$var wire 1 - clk $end
$var wire 8 O external_data_in [7:0] $end
$var wire 1 @ mem_read $end
$var wire 1 = mem_write $end
$var wire 8 P write_data [7:0] $end
$var reg 8 Q read_data [7:0] $end
$upscope $end
$scope module imem $end
$var wire 1 - clk $end
$var wire 8 R address [7:0] $end
$var reg 16 S instruction [15:0] $end
$var integer 32 T i [31:0] $end
$upscope $end
$scope module pc_inst $end
$var wire 1 - clk $end
$var wire 8 U next_pc [7:0] $end
$var wire 1 / reset $end
$var reg 8 V current_pc [7:0] $end
$upscope $end
$scope module rf $end
$var wire 1 - clk $end
$var wire 2 W read_reg1 [1:0] $end
$var wire 2 X read_reg2 [1:0] $end
$var wire 1 4 reg_write $end
$var wire 1 / reset $end
$var wire 8 Y write_data [7:0] $end
$var wire 2 Z write_reg [1:0] $end
$var reg 8 [ read_data1 [7:0] $end
$var reg 8 \ read_data2 [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
b100000000 T
bx S
bx R
bx Q
bx P
b0 O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
xD
bx C
bx B
bx A
x@
bx ?
x>
x=
bx <
bx ;
bx :
bx 9
x8
bx 7
bx 6
bx 5
x4
bx 3
bx 2
bx 1
b0 0
1/
b0 .
0-
bx ,
bx +
bx *
bx )
bx (
bx '
x&
bx %
bx $
x#
bx "
bx !
$end
#5000
b1 9
b0 %
b0 ;
b0 R
b0 V
b0 +
b0 *
b0 )
b0 (
0/
1-
#10000
0-
#15000
b0 ,
b0 C
b10000 !
b10000 E
b10000 K
b10000 N
b10000 G
b10000 H
b0 '
b0 5
b0 P
b0 \
b0 6
b0 J
b0 [
14
1@
0#
0=
1D
b0 F
b0 I
b0 M
0&
08
1>
b10000 B
b0 2
b0 X
b0 3
b0 W
b1 7
b1 Z
b10 $
b10 <
b10 L
b100100000010000 "
b100100000010000 A
b100100000010000 S
bx 9
bx %
bx ;
bx R
bx V
1-
1/
#20000
0-
#25000
bx !
bx E
bx K
bx N
bx G
bx H
bx '
bx 5
bx P
bx \
bx 6
bx J
bx [
04
0@
0D
0>
bx B
bx 2
bx X
bx 3
bx W
bx 7
bx Z
bx $
bx <
bx L
bx 1
bx Y
bx "
bx A
bx S
b10100101 ?
b10100101 Q
bx )
1-
